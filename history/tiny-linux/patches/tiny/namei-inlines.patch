
uninline various namei.c functions


 fs/namei.c |    6 	3 +	3 -	0 !
 1 files changed, 3 insertions(+), 3 deletions(-)

Index: linux-2.6.23-rc9/fs/namei.c
===================================================================
--- linux-2.6.23-rc9.orig/fs/namei.c	2007-10-08 23:51:20.000000000 +0200
+++ linux-2.6.23-rc9/fs/namei.c	2007-10-09 00:30:41.000000000 +0200
@@ -609,7 +609,7 @@
 		char *s = nd_get_link(nd);
 		error = 0;
 		if (s)
-			error = __vfs_follow_link(nd, s);
+			error = vfs_follow_link(nd, s);
 		if (dentry->d_inode->i_op->put_link)
 			dentry->d_inode->i_op->put_link(dentry, nd, cookie);
 	}
@@ -626,7 +626,7 @@
  * Without that kind of total limit, nasty chains of consecutive
  * symlinks can cause almost arbitrarily long lookups. 
  */
-static inline int do_follow_link(struct path *path, struct nameidata *nd)
+static int do_follow_link(struct path *path, struct nameidata *nd)
 {
 	int err = -ELOOP;
 	if (current->link_count >= MAX_NESTED_LINKS)
@@ -1472,7 +1472,7 @@
  *  3. We should have write and exec permissions on dir
  *  4. We can't do it if dir is immutable (done in permission())
  */
-static inline int may_create(struct inode *dir, struct dentry *child,
+static int may_create(struct inode *dir, struct dentry *child,
 			     struct nameidata *nd)
 {
 	if (child->d_inode)
