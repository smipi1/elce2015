
configurable tiny mempool

Reduces mempools to a single element managed with xchg


 include/linux/mempool.h |   20 	20 +	0 -	0 !
 init/Kconfig            |   10 	10 +	0 -	0 !
 mm/mempool.c            |   50 	50 +	0 -	0 !
 3 files changed, 80 insertions(+)

Index: linux-2.6.23-rc9/include/linux/mempool.h
===================================================================
--- linux-2.6.23-rc9.orig/include/linux/mempool.h	2007-07-09 01:32:17.000000000 +0200
+++ linux-2.6.23-rc9/include/linux/mempool.h	2007-10-08 23:52:27.000000000 +0200
@@ -11,6 +11,7 @@
 typedef void * (mempool_alloc_t)(gfp_t gfp_mask, void *pool_data);
 typedef void (mempool_free_t)(void *element, void *pool_data);
 
+#ifdef CONFIG_MEMPOOL
 typedef struct mempool_s {
 	spinlock_t lock;
 	int min_nr;		/* nr of elements at *elements */
@@ -33,6 +34,25 @@
 extern void * mempool_alloc(mempool_t *pool, gfp_t gfp_mask);
 extern void mempool_free(void *element, mempool_t *pool);
 
+#else
+
+typedef struct mempool_s {
+	void *pool_data;
+	void *cache;
+	mempool_alloc_t *alloc;
+	mempool_free_t *free;
+} mempool_t;
+
+extern mempool_t * mempool_create(int min_nr, mempool_alloc_t *alloc_fn,
+				 mempool_free_t *free_fn, void *pool_data);
+extern void * mempool_alloc(mempool_t *pool, int gfp_mask);
+extern void mempool_free(void *element, mempool_t *pool);
+extern void mempool_destroy(mempool_t *pool);
+#define mempool_resize(a, b, c) (0)
+#define mempool_create_node(m, a, f, p, n) mempool_create(m, a, f, p)
+
+#endif
+
 /*
  * A mempool_alloc_t and mempool_free_t that get the memory from
  * a slab that is passed in through pool_data.
Index: linux-2.6.23-rc9/init/Kconfig
===================================================================
--- linux-2.6.23-rc9.orig/init/Kconfig	2007-10-08 23:52:27.000000000 +0200
+++ linux-2.6.23-rc9/init/Kconfig	2007-10-09 00:30:16.000000000 +0200
@@ -639,6 +639,16 @@
        help
 	  Un-inline some function for smaller kernel size.
 
+config MEMPOOL
+	default y
+	bool "Use mempool allocator" if EMBEDDED
+	help
+	  The mempool allocator attempts keep a reserve pool of
+	  various objects available for use in low-memory situations.
+	  Disabling this feature may make more memory available and
+	  will somewhat decrease code size, but with a higher risk of
+	  deadlock under some loads.
+
 endmenu		# General setup
 
 config RT_MUTEXES
Index: linux-2.6.23-rc9/mm/mempool.c
===================================================================
--- linux-2.6.23-rc9.orig/mm/mempool.c	2007-10-08 23:51:25.000000000 +0200
+++ linux-2.6.23-rc9/mm/mempool.c	2007-10-08 23:52:27.000000000 +0200
@@ -15,6 +15,8 @@
 #include <linux/blkdev.h>
 #include <linux/writeback.h>
 
+#ifdef CONFIG_MEMPOOL
+
 static void add_element(mempool_t *pool, void *element)
 {
 	BUG_ON(pool->curr_nr >= pool->min_nr);
@@ -280,6 +282,54 @@
 }
 EXPORT_SYMBOL(mempool_free);
 
+#else /* !CONFIG_MEMPOOL */
+
+mempool_t *mempool_create(int min_nr, mempool_alloc_t *alloc_fn,
+				 mempool_free_t *free_fn, void *pool_data)
+{
+	mempool_t *m;
+
+	m = (mempool_t *)kmalloc(sizeof(mempool_t), GFP_KERNEL);
+
+	if (m) {
+		m->pool_data = pool_data;
+		m->alloc = alloc_fn;
+		m->free = free_fn;
+		m->cache = alloc_fn(GFP_KERNEL, pool_data);
+	}
+
+	return m;
+}
+EXPORT_SYMBOL(mempool_create);
+
+extern void mempool_destroy(mempool_t *pool)
+{
+	if (pool->cache)
+		pool->free(pool->cache, pool->pool_data);
+	kfree(pool);
+}
+EXPORT_SYMBOL(mempool_destroy);
+
+void * mempool_alloc(mempool_t *pool, int gfp_mask)
+{
+	void *p = pool->alloc(gfp_mask, pool->pool_data);
+	if (!p)
+		p = xchg(&pool->cache, p);
+
+	return p;
+}
+EXPORT_SYMBOL(mempool_alloc);
+
+void mempool_free(void *element, mempool_t *pool)
+{
+	element = xchg(&pool->cache, element);
+	if (element)
+		pool->free(element, pool->pool_data);
+}
+EXPORT_SYMBOL(mempool_free);
+
+#endif /* !CONFIG_MEMPOOL */
+
 /*
  * A commonly used alloc and free fn.
  */
