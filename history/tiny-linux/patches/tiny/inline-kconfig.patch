    Added configration to select whether linuxtiny un-inlining patch
    should take effect.

---
 fs/buffer.c     |    4 	4 +	0 -	0 !
 fs/ext2/namei.c |    4 	4 +	0 -	0 !
 fs/namei.c      |   13 	13 +	0 -	0 !
 init/Kconfig    |    6 	6 +	0 -	0 !
 4 files changed, 27 insertions(+)

Index: linux-2.6.23-rc9/init/Kconfig
===================================================================
--- linux-2.6.23-rc9.orig/init/Kconfig	2007-10-08 23:52:27.000000000 +0200
+++ linux-2.6.23-rc9/init/Kconfig	2007-10-09 00:30:34.000000000 +0200
@@ -590,6 +590,12 @@
 	    Some tests show impressive .text shrinkage from using
 	    unit-at-a-time compilation.
 
+config LINUXTINY_DO_UNINLINE
+       bool "un-inline several functions for smaller kernel size" if EMBEDDED
+       default n
+       help
+	  Un-inline some function for smaller kernel size.
+
 endmenu		# General setup
 
 config RT_MUTEXES
Index: linux-2.6.23-rc9/fs/buffer.c
===================================================================
--- linux-2.6.23-rc9.orig/fs/buffer.c	2007-10-08 23:52:27.000000000 +0200
+++ linux-2.6.23-rc9/fs/buffer.c	2007-10-08 23:52:27.000000000 +0200
@@ -564,7 +564,11 @@
 /*
  * The buffer's backing address_space's private_lock must be held
  */
+#ifdef CONFIG_LINUXTINY_DO_UNINLINE
 static void __remove_assoc_queue(struct buffer_head *bh)
+#else
+static inline void __remove_assoc_queue(struct buffer_head *bh)
+#endif
 {
 	list_del_init(&bh->b_assoc_buffers);
 	WARN_ON(!bh->b_assoc_map);
Index: linux-2.6.23-rc9/fs/namei.c
===================================================================
--- linux-2.6.23-rc9.orig/fs/namei.c	2007-10-08 23:52:27.000000000 +0200
+++ linux-2.6.23-rc9/fs/namei.c	2007-10-08 23:52:27.000000000 +0200
@@ -609,7 +609,11 @@
 		char *s = nd_get_link(nd);
 		error = 0;
 		if (s)
+#ifdef CONFIG_LINUXTINY_DO_UNINLINE
 			error = vfs_follow_link(nd, s);
+#else
+			error = __vfs_follow_link(nd, s);
+#endif
 		if (dentry->d_inode->i_op->put_link)
 			dentry->d_inode->i_op->put_link(dentry, nd, cookie);
 	}
@@ -626,7 +630,11 @@
  * Without that kind of total limit, nasty chains of consecutive
  * symlinks can cause almost arbitrarily long lookups. 
  */
+#ifdef CONFIG_LINUXTINY_DO_UNINLINE
 static int do_follow_link(struct path *path, struct nameidata *nd)
+#else
+static inline int do_follow_link(struct path *path, struct nameidata *nd)
+#endif
 {
 	int err = -ELOOP;
 	if (current->link_count >= MAX_NESTED_LINKS)
@@ -1472,8 +1480,13 @@
  *  3. We should have write and exec permissions on dir
  *  4. We can't do it if dir is immutable (done in permission())
  */
+#ifdef CONFIG_LINUXTINY_DO_UNINLINE
 static int may_create(struct inode *dir, struct dentry *child,
 			     struct nameidata *nd)
+#else
+static inline int may_create(struct inode *dir, struct dentry *child,
+			     struct nameidata *nd)
+#endif
 {
 	if (child->d_inode)
 		return -EEXIST;
Index: linux-2.6.23-rc9/fs/ext2/namei.c
===================================================================
--- linux-2.6.23-rc9.orig/fs/ext2/namei.c	2007-10-08 23:52:27.000000000 +0200
+++ linux-2.6.23-rc9/fs/ext2/namei.c	2007-10-08 23:52:27.000000000 +0200
@@ -36,7 +36,11 @@
 #include "acl.h"
 #include "xip.h"
 
+#ifdef CONFIG_LINUXTINY_DO_UNINLINE
 static int ext2_add_nondir(struct dentry *dentry, struct inode *inode)
+#else
+static inline int ext2_add_nondir(struct dentry *dentry, struct inode *inode)
+#endif
 {
 	int err = ext2_add_link(dentry, inode);
 	if (!err) {
