inflate: remove legacy DEBG macros

Signed-off-by: Matt Mackall <mpm@selenic.com>

Index: linux-2.6.16.19/lib/inflate.c
===================================================================
--- linux-2.6.16.19.orig/lib/inflate.c	2006-06-23 17:06:33.000000000 -0700
+++ linux-2.6.16.19/lib/inflate.c	2006-06-23 17:06:36.000000000 -0700
@@ -1,5 +1,3 @@
-#define DEBG(x)
-#define DEBG1(x)
 /* inflate.c -- Not copyrighted 1992 by Mark Adler
  * version c10p1, 10 January 1993
  *
@@ -418,8 +416,6 @@
 	int y;			/* number of dummy codes added */
 	unsigned z;		/* number of entries in current table */
 
-	DEBG("huft1 ");
-
 	for (i = 0; i < BMAX + 1; i++)
 		c[i] = 0;
 
@@ -437,8 +433,6 @@
 		return 2;
 	}
 
-	DEBG("huft2 ");
-
 	/* Find minimum and maximum length, bound *m by those */
 	l = *m;
 	for (j = 1; j <= BMAX; j++)
@@ -457,8 +451,6 @@
 		l = i;
 	*m = l;
 
-	DEBG("huft3 ");
-
 	/* Adjust last length count to fill out codes, if needed */
 	for (y = 1 << j; j < i; j++, y <<= 1) {
 		y -= c[j];
@@ -471,8 +463,6 @@
 		return 2;
 	c[i] += y;
 
-	DEBG("huft4 ");
-
 	/* Generate starting offsets into the value table for each length */
 	x[1] = j = 0;
 	p = c + 1;
@@ -485,8 +475,6 @@
 		xp++;
 	}
 
-	DEBG("huft5 ");
-
 	/* Make a table of values in order of bit lengths */
 	p = b;
 	i = 0;
@@ -498,8 +486,6 @@
 
 	n = x[g];                   /* set n to length of v */
 
-	DEBG("h6 ");
-
 	/* Generate the Huffman codes and for each, make the table entries */
 	x[0] = i = 0; /* first Huffman code is zero */
 	p = v; /* grab values in bit order */
@@ -508,18 +494,14 @@
 	u[0] = NULL; /* just to keep compilers happy */
 	q = NULL; /* ditto */
 	z = 0; /* ditto */
-	DEBG("h6a ");
 
 	/* go through the bit lengths (k already is bits in shortest code) */
 	for (; k <= g; k++) {
-		DEBG("h6b ");
 		a = c[k];
 		while (a--) {
-			DEBG("h6b1 ");
 			/* i is the Huffman code of length k for value *p */
 			/* make tables up to required level */
 			while (k > w + l) {
-				DEBG1("1 ");
 				h++;
 				w += l;	/* previous table always l bits */
 
@@ -532,7 +514,6 @@
 				f = 1 << j;
 				if (f > a + 1) {
 					/* too few codes for k-w bit table */
-					DEBG1("2 ");
 					/* deduct codes from patterns left */
 					f -= a + 1;
 					xp = c + k;
@@ -549,7 +530,6 @@
 					}
     				}
 
-				DEBG1("3 ");
 				/* table entries for j-bit table */
 				z = 1 << j;
 
@@ -561,13 +541,11 @@
 					return 3;	/* not enough memory */
 				}
 
-				DEBG1("4 ");
 				*t = q + 1; /* link to list for huft_free */
 				t = &q->next;
 				*t = NULL;
 				u[h] = ++q;	/* table starts after link */
 
-				DEBG1("5 ");
 				/* connect to last table, if there is one */
 				if (h) {
 					/* save pattern for backing up */
@@ -583,9 +561,7 @@
 					/* connect to last table */
 					u[h - 1][j] = r;
 				}
-				DEBG1("6 ");
 			}
-			DEBG("h6c ");
 
 			/* set up table entry in r */
 			r.bits = (u8)(k - w);
@@ -603,7 +579,6 @@
 				r.extra = (u8)e[*p - s];
 				r.val = d[*p++ - s];
 			}
-			DEBG("h6d ");
 
 			/* fill code-like entries with r */
 			f = 1 << (k - w);
@@ -620,13 +595,9 @@
 				h--;	/* don't need to update q */
 				w -= l;
 			}
-			DEBG("h6e ");
 		}
-		DEBG("h6f ");
 	}
 
-	DEBG("huft7 ");
-
 	/* Return true (1) if we were given an incomplete table */
 	return y && g != 1;
 }
@@ -715,8 +686,6 @@
 {
 	unsigned n;		/* number of bytes in block */
 
-	DEBG("<stor");
-
 	/* go to byte boundary */
 	dumpbits(io, io->bits & 7);
 
@@ -729,7 +698,6 @@
 	while (n--)
 		put_byte(io, readbyte(io));
 
-	DEBG(">");
 	return 0;
 }
 
@@ -752,8 +720,6 @@
 	int bd;			/* lookup bits for td */
 	unsigned l[N_MAX];	/* length list for huft_build */
 
-	DEBG("<fix");
-
 	/* set up literal table */
 	for (i = 0; i < 144; i++)
 		l[i] = 8;
@@ -774,7 +740,6 @@
 	if ((i = huft_build(l, 30, 0, cpdist, cpdext, &td, &bd)) > 1) {
 		huft_free(tl);
 
-		DEBG(">");
 		return i;
 	}
 
@@ -808,8 +773,6 @@
 	unsigned nd;		/* number of distance codes */
 	unsigned ll[286 + 30];	/* literal/length and distance code lengths */
 
-	DEBG("<dyn");
-
 	/* read in table lengths */
 	nl = 257 + pullbits(io, 5); /* number of literal/length codes */
 	nd = 1 + pullbits(io, 5); /* number of distance codes */
@@ -817,16 +780,12 @@
 	if (nl > 286 || nd > 30)
 		return 1;	/* bad lengths */
 
-	DEBG("dyn1 ");
-
 	/* read in bit-length-code lengths */
 	for (j = 0; j < nb; j++)
 		ll[border[j]] = pullbits(io, 3);
 	for (; j < 19; j++)
 		ll[border[j]] = 0;
 
-	DEBG("dyn2 ");
-
 	/* build decoding table for trees--single level, 7 bit lookup */
 	bl = 7;
 	if ((i = huft_build(ll, 19, 19, 0, 0, &tl, &bl))) {
@@ -835,8 +794,6 @@
 		return i;	/* incomplete code set */
 	}
 
-	DEBG("dyn3 ");
-
 	/* read in literal and distance code lengths */
 	n = nl + nd;
 	i = l = 0;
@@ -869,29 +826,21 @@
 		}
 	}
 
-	DEBG("dyn4 ");
-
 	/* free decoding table for trees */
 	huft_free(tl);
 
-	DEBG("dyn5 ");
-
-	DEBG("dyn5a ");
-
 	/* build the decoding tables for literal/length and distance codes */
 	bl = lbits;
 	if ((i = huft_build(ll, nl, 257, cplens, cplext, &tl, &bl))) {
-		DEBG("dyn5b ");
 		if (i == 1) {
 			io->error("incomplete literal tree");
 			huft_free(tl);
 		}
 		return i;	/* incomplete code set */
 	}
-	DEBG("dyn5c ");
+
 	bd = dbits;
 	if ((i = huft_build(ll + nl, nd, 0, cpdist, cpdext, &td, &bd))) {
-		DEBG("dyn5d ");
 		if (i == 1) {
 			io->error("incomplete distance tree");
 			huft_free(td);
@@ -900,19 +849,14 @@
 		return i;	/* incomplete code set */
 	}
 
-	DEBG("dyn6 ");
-
 	/* decompress until an end-of-block code */
 	if (inflate_codes(io, tl, td, bl, bd))
 		return 1;
 
-	DEBG("dyn7 ");
-
 	/* free the decoding tables, return */
 	huft_free(tl);
 	huft_free(td);
 
-	DEBG(">");
 	return 0;
 }
 
@@ -924,8 +868,6 @@
 {
 	unsigned t;		/* block type */
 
-	DEBG("<blk");
-
 	*e = pullbits(io, 1); /* read in last block bit */
 	t = pullbits(io, 2); /* read in block type */
 
@@ -937,8 +879,6 @@
 	if (t == 1)
 		return inflate_fixed(io);
 
-	DEBG(">");
-
 	/* bad block type */
 	return 2;
 }
