---
 scripts/casort    |  105 	105 +	0 -	0 !
 scripts/slabalyze |  143 	143 +	0 -	0 !
 2 files changed, 248 insertions(+)

Index: linux-2.6.23-rc9/scripts/casort
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.23-rc9/scripts/casort	2007-10-08 23:52:27.000000000 +0200
@@ -0,0 +1,105 @@
+#!/usr/bin/env python
+#
+# casort - show sorted info from /proc/cache_account
+#
+# Written: by Tim Bird <tim.bird@am.sony.com>
+# Copyright: 2007 Sony Corporation
+# License: GPL v2
+
+import sys, re
+
+if "-h" in sys.argv or "--help" in sys.argv:
+	print """Usage: sasort [options]
+-h,--help  Show this usage help
+-f <file>  Read slab account data from <file>, instead of /proc/cache_account
+-s <sort_field>  Sort by the indicated field.  Fields are:
+     'n' = net, 's'=slack, 't'=total, 'a'='allocs', 'h'=highwater, 'c'=caller
+
+total = total cumulative amount of memory that a caller has allocated
+
+slack = cumulative overhead for a caller's allocations.  This is the
+cumulative difference between what the size the caller requested and
+what the size of memory they received.
+
+net = amount of memory currently allocated and actually in-use.
+This does not include overhead for cache and slab structures.
+
+allocs = number of allocations by a caller
+frees = number of frees by a caller
+
+highwater = maximum net memory that a caller had in use since the
+kernel booted."""
+	sys.exit(0)
+
+cacheaccount_file = "/proc/cache_account"
+if "-f" in sys.argv:
+	cacheaccount_file = sys.argv[sys.argv.index('-f')+1]
+
+sort_field = 'c'
+if "-s" in sys.argv:
+	sort_field = sys.argv[sys.argv.index('-s')+1]
+
+class stub_class:
+	pass
+
+try:
+	lines = open(cacheaccount_file).readlines()
+except:
+	print "Error: Can't open file '%s'." % cacheaccount_file
+	if cacheaccount_file.startswith("/proc/"):
+		print """Missing file in /proc.  Make sure your kernel is configured
+with support for CONFIG_DEBUG_SLAB_ACCOUNT."""
+	sys.exit(1)
+
+allocators = {}
+active_memory = 0
+total_memory = 0
+
+# collect data from the file
+in_data = 0
+for line in lines[2:]:
+	items = line.split()
+	if not in_data:
+		if items and items[0]=="total":
+			in_data = 1
+		else:
+			print line,
+		continue
+
+	allocator = stub_class()
+	allocator.total = int(items[0])
+	allocator.slack = int(items[1])
+	allocator.net = int(items[2])
+	allocator.allocs = int(items[3].split('/')[0])
+	allocator.frees = int(items[3].split('/')[1])
+	allocator.highwater = int(items[4])
+	caller = items[5]
+	allocator.caller = caller
+	allocators[caller] = allocator
+
+def sort_value(allocator):
+	global sort_field
+
+	if sort_field=='a':
+		return allocator.allocs
+	if sort_field=='t':
+		return allocator.total
+	if sort_field=='n':
+		return allocator.net
+	if sort_field=='h':
+		return allocator.highwater
+	if sort_field=='c':
+		return allocator.caller
+	return allocator.caller
+
+def sort_allocator(a, b):
+	return cmp(sort_value(a), sort_value(b))
+
+# display the collected data
+line_format = "%8s %8s %8s %5s/%-5s %8s %s"
+print line_format % ("total", "slack", "net", "alloc", "free", "highwater", "caller")
+allocator_list = allocators.values()
+allocator_list.sort(sort_allocator)
+for a in allocator_list:
+	print line_format % (a.total, a.slack, a.net, a.allocs, a.frees,
+			a.highwater, a.caller)
Index: linux-2.6.23-rc9/scripts/slabalyze
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.23-rc9/scripts/slabalyze	2007-10-08 23:52:27.000000000 +0200
@@ -0,0 +1,143 @@
+#!/usr/bin/env python
+#
+# slabalyze - analyze the information from /proc/slabinfo
+#
+# Written: by Tim Bird <tim.bird@am.sony.com>
+# Copyright: 2007 by Sony Corporation
+# License: GPL v2
+
+import sys, re
+
+if "-h" in sys.argv or "--help" in sys.argv:
+	print """Usage: slabalyze [options]
+-h,--help  Show this usage help
+-z	   Show empty caches
+-f <file>  Read slab data from indicated file, instead of /proc/slabinfo
+-s <sort_field>  Sort by the indicated field.  Fields are:
+     'a' = active, 'o'=overhead, 't'=total
+
+active memory = amount of memory in a cache that is currently allocated
+and actually in-use.  This does not include overhead for cache and slab
+structures.
+
+overhead = amount of memory taken by the cache, but not directly
+used for active object allocations.  This includes bookkeeping overhead
+as well as unused (free) objects.
+
+total memory = total amount of memory currently used for a cache
+
+"""
+	sys.exit(0)
+
+show_empty = 0
+if "-z" in sys.argv:
+	show_empty = 1
+
+slabinfo_file = "/proc/slabinfo"
+if "-f" in sys.argv:
+	slabinfo_file = sys.argv[sys.argv.index('-f')+1]
+
+sort_field = 'n'
+if "-s" in sys.argv:
+	sort_field = sys.argv[sys.argv.index('-s')+1]
+
+page_size = 4096
+
+class stub_class:
+	pass
+
+lines = open(slabinfo_file).readlines()
+caches = {}
+active_memory = 0
+total_memory = 0
+
+# collect data from the file
+for line in lines[2:]:
+	items = line.split()
+	name = items[0]
+	cache = stub_class()
+	cache.name = name
+	caches[name] = cache
+	cache.active_objs = int(items[1])
+	cache.num_objs = int(items[2])
+	cache.objsize = int(items[3])
+	cache.objperslab = int(items[4])
+	cache.pagesperslab = int(items[5])
+	cache.active_slabs = int(items[13])
+	cache.num_slabs = int(items[14])
+
+	# calculated items
+	cache.active_memory = cache.active_objs * cache.objsize
+	cache.total_memory = cache.num_slabs * cache.pagesperslab * page_size
+	cache.overhead = cache.total_memory - cache.active_memory
+
+	active_memory += cache.active_memory
+	total_memory += cache.total_memory
+
+overhead = total_memory - active_memory
+
+def sort_value(cache):
+	global sort_field
+
+	if sort_field=='a':
+		return cache.active_memory
+	if sort_field=='o':
+		return cache.overhead
+	if sort_field=='t':
+		return cache.total_memory
+	return cache.name
+
+def mixed_str_cmp(a, b):
+	# if both strings have the same prefix, but end in a number,
+	# sort them numerically by the number
+	# this is for cases like 'size-32' vs. 'size-1024'
+
+	# remove DMA from end of string, if present (but remember it)
+	a_dma = ''
+	if a.endswith('(DMA)'):
+		a = a[:-5]
+		a_dma='DMA'
+	b_dma = ''
+	if b.endswith('(DMA)'):
+		b= b[:-5]
+		b_dma='DMA'
+
+	# just do regular string compare on strings NOT ending with a number
+	num_end_pat = '.*-[0-9]+$'
+	if not re.match(num_end_pat, a) or not re.match(num_end_pat, b):
+		return cmp(a, b)
+
+	str_a = '-'.join(a.split('-')[:-1])+a_dma
+	str_b = '-'.join(b.split('-')[:-1])+b_dma
+	int_a = int(a.split('-')[-1])
+	int_b = int(b.split('-')[-1])
+	if str_a != str_b:
+		# if not same prefix, compare the strings
+		return cmp(str_a, str_b)
+	else:
+		return cmp(int_a, int_b)
+
+def sort_cache(cache_a, cache_b):
+	global sort_field
+	a = sort_value(cache_a)
+	b = sort_value(cache_b)
+
+	if sort_field == 'n':
+		# handle names somewhat differently
+		return mixed_str_cmp(a, b)
+	else:
+		return cmp(a, b)
+
+# display the collected data
+line_format = "%-25s %10s %10s %10s"
+print line_format % ("<Name>", "<active>", "<overhead>", "<total>")
+cache_list = caches.values()
+cache_list.sort(sort_cache)
+for cache in cache_list:
+	if show_empty or cache.total_memory:
+		print line_format % (cache.name, cache.active_memory, \
+			cache.overhead, cache.total_memory)
+
+print line_format % \
+	("TOTAL", active_memory, overhead, total_memory)
+
