
configurable sysenter support


 arch/i386/kernel/Makefile     |    3 	2 +	1 -	0 !
 arch/i386/kernel/cpu/common.c |    4 	4 +	0 -	0 !
 arch/i386/kernel/entry.S      |    8 	8 +	0 -	0 !
 arch/i386/kernel/sysenter.c   |   12 	12 +	0 -	0 !
 arch/i386/power/cpu.c         |    2 	2 +	0 -	0 !
 include/asm-i386/elf.h        |    2 	2 +	0 -	0 !
 init/Kconfig                  |    8 	8 +	0 -	0 !
 7 files changed, 38 insertions(+), 1 deletion(-)

Index: linux-2.6.23-rc9/arch/i386/kernel/Makefile
===================================================================
--- linux-2.6.23-rc9.orig/arch/i386/kernel/Makefile	2007-10-08 23:50:37.000000000 +0200
+++ linux-2.6.23-rc9/arch/i386/kernel/Makefile	2007-10-08 23:52:27.000000000 +0200
@@ -31,7 +31,8 @@
 obj-$(CONFIG_X86_SUMMIT_NUMA)	+= summit.o
 obj-$(CONFIG_KPROBES)		+= kprobes.o
 obj-$(CONFIG_MODULES)		+= module.o
-obj-y				+= sysenter.o vsyscall.o
+obj-y				+= sysenter.o
+obj-$(CONFIG_SYSENTER)		+= vsyscall.o
 obj-$(CONFIG_ACPI_SRAT) 	+= srat.o
 obj-$(CONFIG_EFI) 		+= efi.o efi_stub.o
 obj-$(CONFIG_DOUBLEFAULT) 	+= doublefault.o
Index: linux-2.6.23-rc9/arch/i386/kernel/cpu/common.c
===================================================================
--- linux-2.6.23-rc9.orig/arch/i386/kernel/cpu/common.c	2007-10-08 23:50:37.000000000 +0200
+++ linux-2.6.23-rc9/arch/i386/kernel/cpu/common.c	2007-10-08 23:52:27.000000000 +0200
@@ -508,8 +508,10 @@
 void __init identify_boot_cpu(void)
 {
 	identify_cpu(&boot_cpu_data);
+#ifdef CONFIG_SYSENTER
 	sysenter_setup();
 	enable_sep_cpu();
+#endif
 	mtrr_bp_init();
 }
 
@@ -517,7 +519,9 @@
 {
 	BUG_ON(c == &boot_cpu_data);
 	identify_cpu(c);
+#ifdef CONFIG_SYSENTER
 	enable_sep_cpu();
+#endif
 	mtrr_ap_init();
 }
 
Index: linux-2.6.23-rc9/arch/i386/kernel/entry.S
===================================================================
--- linux-2.6.23-rc9.orig/arch/i386/kernel/entry.S	2007-10-08 23:50:37.000000000 +0200
+++ linux-2.6.23-rc9/arch/i386/kernel/entry.S	2007-10-08 23:52:27.000000000 +0200
@@ -283,6 +283,7 @@
 
 	# sysenter call handler stub
 ENTRY(sysenter_entry)
+#ifdef CONFIG_SYSENTER
 	CFI_STARTPROC simple
 	CFI_SIGNAL_FRAME
 	CFI_DEF_CFA esp, 0
@@ -359,6 +360,7 @@
 	.long 1b,2b
 .popsection
 ENDPROC(sysenter_entry)
+#endif
 
 	# system call handler stub
 ENTRY(system_call)
@@ -747,6 +749,8 @@
  * by hand onto the new stack - while updating the return eip past
  * the instruction that would have done it for sysenter.
  */
+
+#ifdef CONFIG_SYSENTER
 #define FIX_STACK(offset, ok, label)		\
 	cmpw $__KERNEL_CS,4(%esp);		\
 	jne ok;					\
@@ -761,6 +765,10 @@
 	pushl $sysenter_past_esp;		\
 	CFI_ADJUST_CFA_OFFSET 4;		\
 	CFI_REL_OFFSET eip, 0
+#else
+#define FIX_STACK(offset, ok, label) \
+label:
+#endif
 
 KPROBE_ENTRY(debug)
 	RING0_INT_FRAME
Index: linux-2.6.23-rc9/arch/i386/power/cpu.c
===================================================================
--- linux-2.6.23-rc9.orig/arch/i386/power/cpu.c	2007-07-09 01:32:17.000000000 +0200
+++ linux-2.6.23-rc9/arch/i386/power/cpu.c	2007-10-08 23:52:27.000000000 +0200
@@ -111,11 +111,13 @@
  	loadsegment(gs, ctxt->gs);
  	loadsegment(ss, ctxt->ss);
 
+#ifdef CONFIG_SYSENTER
 	/*
 	 * sysenter MSRs
 	 */
 	if (boot_cpu_has(X86_FEATURE_SEP))
 		enable_sep_cpu();
+#endif
 
 	fix_processor_context();
 	do_fpu_end();
Index: linux-2.6.23-rc9/include/asm-i386/elf.h
===================================================================
--- linux-2.6.23-rc9.orig/include/asm-i386/elf.h	2007-07-09 01:32:17.000000000 +0200
+++ linux-2.6.23-rc9/include/asm-i386/elf.h	2007-10-08 23:52:27.000000000 +0200
@@ -152,11 +152,13 @@
 
 extern unsigned int vdso_enabled;
 
+#ifdef CONFIG_SYSENTER
 #define ARCH_DLINFO							\
 do if (vdso_enabled) {							\
 		NEW_AUX_ENT(AT_SYSINFO,	VDSO_ENTRY);			\
 		NEW_AUX_ENT(AT_SYSINFO_EHDR, VDSO_CURRENT_BASE);	\
 } while (0)
+#endif
 
 #endif
 
Index: linux-2.6.23-rc9/init/Kconfig
===================================================================
--- linux-2.6.23-rc9.orig/init/Kconfig	2007-10-08 23:52:27.000000000 +0200
+++ linux-2.6.23-rc9/init/Kconfig	2007-10-09 00:30:11.000000000 +0200
@@ -334,6 +334,14 @@
 
 endif
 
+config SYSENTER
+	depends X86
+	default y
+	bool "Enable syscalls via sysenter" if EMBEDDED
+	help
+	  Disabling this feature removes sysenter handling as well as
+	  vsyscall fixmaps.
+
 config MEASURE_INLINES
 	default n
 	bool "Enable inline measurement" if EMBEDDED
Index: linux-2.6.23-rc9/arch/i386/kernel/sysenter.c
===================================================================
--- linux-2.6.23-rc9.orig/arch/i386/kernel/sysenter.c	2007-10-08 23:50:37.000000000 +0200
+++ linux-2.6.23-rc9/arch/i386/kernel/sysenter.c	2007-10-08 23:52:27.000000000 +0200
@@ -38,6 +38,9 @@
 #define VDSO_DEFAULT	VDSO_ENABLED
 #endif
 
+
+#ifdef CONFIG_SYSENTER
+
 /*
  * Should the kernel map a VDSO page into processes and pass its
  * address down to glibc upon exec()?
@@ -318,6 +321,7 @@
 	return ret;
 }
 
+
 const char *arch_vma_name(struct vm_area_struct *vma)
 {
 	if (vma->vm_mm && vma->vm_start == (long)vma->vm_mm->context.vdso)
@@ -335,6 +339,14 @@
 	return NULL;
 }
 
+#else
+unsigned int __read_mostly vdso_enabled = 0;
+void enable_sep_cpu(void) { }
+int arch_setup_additional_pages(struct linux_binprm *bprm, int exstack) { return 0; }
+const char *arch_vma_name(struct vm_area_struct *vma) { return NULL; }
+struct vm_area_struct *get_gate_vma(struct task_struct *tsk) { return NULL; }
+#endif
+
 int in_gate_area(struct task_struct *task, unsigned long addr)
 {
 	const struct vm_area_struct *vma = get_gate_vma(task);
