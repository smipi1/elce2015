This patch introduces a simple allocator for tracking reservations of
block and character device ranges. After poking around, I came to the
conclusion that we can't avoid having a separate data structure for
reservations vs currently available devices so I tidied up the current
scheme.

The new allocator is a simple linked list of dev_t range start and end
points. This lets us allocate regions of multiple majors (as is done
by SCSI) or just a portion of a major (as is done by several types of
character device). Dynamic allocation is handled by passing in a start
and end base address.

This unifies a lot of the code for registering block and character. It
also does away with the hash tables, which were complicating the code
and made allocating more devices than available hash table entries
difficult. As these tables are now only used at driver load, unload,
and for /proc/devices, and the number of entries is relatively
limited, the hash tables are no longer necessary.

Index: linux-2.6.16.19/block/genhd.c
===================================================================
--- linux-2.6.16.19.orig/block/genhd.c	2006-05-30 17:31:44.000000000 -0700
+++ linux-2.6.16.19/block/genhd.c	2006-06-23 13:47:08.000000000 -0700
@@ -54,54 +54,23 @@
 
 int register_blkdev(unsigned int major, const char *name)
 {
-	struct blk_major_name **n, *p;
-	int index, ret = 0;
+	dev_t r;
+	int ret;
 
 	down(&block_subsys_sem);
 
-	/* temporary */
-	if (major == 0) {
-		for (index = ARRAY_SIZE(major_names)-1; index > 0; index--) {
-			if (major_names[index] == NULL)
-				break;
-		}
-
-		if (index == 0) {
-			printk("register_blkdev: failed to get major for %s\n",
-			       name);
-			ret = -EBUSY;
-			goto out;
-		}
-		major = index;
-		ret = major;
-	}
-
-	p = kmalloc(sizeof(struct blk_major_name), GFP_KERNEL);
-	if (p == NULL) {
-		ret = -ENOMEM;
-		goto out;
-	}
-
-	p->major = major;
-	strlcpy(p->name, name, sizeof(p->name));
-	p->next = NULL;
-	index = major_to_index(major);
-
-	for (n = &major_names[index]; *n; n = &(*n)->next) {
-		if ((*n)->major == major)
-			break;
-	}
-	if (!*n)
-		*n = p;
-	else
-		ret = -EBUSY;
+	if (!major) {
+		ret = register_dev(MKDEV(1, 0), MKDEV(254, 0),
+				   MKDEV(1, 0), name, &blkdev_names, &r);
+		ret = ret ? ret : MAJOR(r);
+	} else
+		ret = register_dev(MKDEV(major, 0), MKDEV(major, 0),
+				   MKDEV(1, 0), name, &blkdev_names, NULL);
 
-	if (ret < 0) {
+	if (ret == -EBUSY)
 		printk("register_blkdev: cannot get major %d for %s\n",
 		       major, name);
-		kfree(p);
-	}
-out:
+
 	up(&block_subsys_sem);
 	return ret;
 }
@@ -111,24 +80,11 @@
 /* todo: make void - error printk here */
 int unregister_blkdev(unsigned int major, const char *name)
 {
-	struct blk_major_name **n;
-	struct blk_major_name *p = NULL;
-	int index = major_to_index(major);
-	int ret = 0;
+	int ret;
 
 	down(&block_subsys_sem);
-	for (n = &major_names[index]; *n; n = &(*n)->next)
-		if ((*n)->major == major)
-			break;
-	if (!*n || strcmp((*n)->name, name))
-		ret = -EINVAL;
-	else {
-		p = *n;
-		*n = p->next;
-	}
+	ret = unregister_dev(MKDEV(major, 0), &blkdev_names);
 	up(&block_subsys_sem);
-	kfree(p);
-
 	return ret;
 }
 
Index: linux-2.6.16.19/fs/char_dev.c
===================================================================
--- linux-2.6.16.19.orig/fs/char_dev.c	2006-05-30 17:31:44.000000000 -0700
+++ linux-2.6.16.19/fs/char_dev.c	2006-06-23 13:47:08.000000000 -0700
@@ -20,6 +20,8 @@
 #include <linux/kobject.h>
 #include <linux/kobj_map.h>
 #include <linux/cdev.h>
+#include <linux/list.h>
+#include <linux/devlist.h>
 
 #ifdef CONFIG_KMOD
 #include <linux/kmod.h>
Index: linux-2.6.16.19/fs/devlist.c
===================================================================
--- linux-2.6.16.19.orig/fs/devlist.c	2006-04-21 14:09:39.654033432 -0700
+++ linux-2.6.16.19/fs/devlist.c	2006-06-23 13:47:08.000000000 -0700
@@ -0,0 +1,115 @@
+/*
+ * A simple device node space allocator for the Linux kernel
+ *
+ * This uses a simple linked list of dev_t ranges for reserving device
+ * areas. The io resource tree scheme would almost work here except we
+ * have backwards compatibility requirements for dynamically allocated
+ * ranges from the top of the legacy device space downwards.
+ *
+ * Feb 27 2005  Matt Mackall <mpm@selenic.com>
+ */
+
+#include <linux/kernel.h>
+#include <linux/list.h>
+#include <linux/slab.h>
+#include <linux/kdev_t.h>
+#include <linux/errno.h>
+
+struct device_name {
+	struct list_head list;
+	dev_t begin, end;
+	char name[16];
+};
+
+/*
+ * register_dev - reserve a range of devices for a given device name
+ * @a: first allowed base address
+ * @b: last allowed base address
+ * @size: size of minor devices device range to reserve
+ * @name: name to associate with the range
+ * @list: device name list to add to
+ * @r: allocated base address
+ *
+ * This function reserves a range of %size minor devices starting
+ * somewhere between a and b of the given size. To allocate at a fixed
+ * base address, use a = b. For dynamic allocation in a range,
+ * allocation occurs from the top down for backward compatibility.
+ * There are no restrictions on the size of the range allocated, so
+ * multiple contiguous majors can be allocated with a single call.
+ *
+ * This function returns 0 on success, -EBUSY if the requested range
+ * could not be allocated, and -ENOMEM if the device name node could
+ * not be allocated.
+ */
+
+int register_dev(dev_t a, dev_t b, int size, const char * name,
+		 struct list_head *list, dev_t *r)
+{
+	struct device_name *d;
+	struct list_head *l;
+
+	/* search for insertion point in reverse for dynamic allocation */
+	list_for_each_prev(l, list) {
+		d = list_entry(l, struct device_name, list);
+		/* have we found an insertion point? */
+		if (b >= d->end)
+			break;
+		/* does the current entry force us to shrink the range? */
+		if (b + size > d->begin)
+			b = d->begin - size;
+		/* have we searched outside of or collapsed the range? */
+		if (a > d->begin || a > b)
+			return -EBUSY;
+	}
+
+	d = kmalloc(sizeof(struct device_name), GFP_KERNEL);
+	if (!d)
+		return -ENOMEM;
+
+	strlcpy(d->name, name, sizeof(d->name));
+	d->begin = b;
+	d->end = b + size;
+	list_add(&d->list, l);
+
+	if (r)
+		*r = b;
+
+	return 0;
+}
+
+/*
+ * unregister_dev - drop a device reservation range
+ * @begin: beginning of allocated range
+ * @l: device name list
+ *
+ * This function removes the range starting with begin from the given
+ * list and returns 0, or returns -EINVAL if the range is not found.
+ */
+
+int unregister_dev(dev_t begin, struct list_head *l)
+{
+	struct device_name *n;
+
+	list_for_each_entry(n, l, list)
+		if (n->begin == begin) {
+			list_del(&n->list);
+			kfree(n);
+			return 0;
+		}
+
+	return -EINVAL;
+}
+
+#ifdef CONFIG_PROC_FS
+int get_dev_list(char *p, struct list_head *l)
+{
+	struct device_name *n;
+	int len = 0, m;
+
+	list_for_each_entry(n, l, list)
+		for (m = MAJOR(n->begin); m <= MAJOR(n->end - 1); m++)
+			len += sprintf(p + len, "%3d %s\n", m, n->name);
+
+	return len;
+}
+#endif
Index: linux-2.6.16.19/include/linux/devlist.h
===================================================================
--- linux-2.6.16.19.orig/include/linux/devlist.h	2006-04-21 14:09:39.654033432 -0700
+++ linux-2.6.16.19/include/linux/devlist.h	2006-06-23 13:47:08.000000000 -0700
@@ -0,0 +1,11 @@
+#ifndef _LINUX_DEVLIST_H
+#define _LINUX_DEVLIST_H
+
+int register_dev(dev_t a, dev_t b, int size, const char * name,
+		 struct list_head *list, dev_t *r);
+
+int unregister_dev(dev_t begin, struct list_head *l);
+
+int get_dev_list(char *p, struct list_head *l);
+
+#endif
